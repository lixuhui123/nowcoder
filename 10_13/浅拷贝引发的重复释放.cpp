//class A
//{
//
//};
//class B
//{
//	A *p;
//public:
//	B()
//	{
//		p = new A;
//	}
//	~B()
//	{
//		delete p;
//	}
//};
//void  sayHellow(B b)
//{
//	/* 传参相当于浅拷贝，产生出来两个对象，体统要析构两次，但是浅拷贝只是拷贝了
//	对象的内存空间，并没有拷贝对象里面指针变量所指向的那片空间。只是新的指针空间去指向上一个
//对象的new出来的空间。所以析构时，会产生重复释放，程序崩溃，加引用会解决这个问题。	*/
//}
//int main()
//{
//	B b;
//	sayHellow(b);
//}
//
//
//
//
//
